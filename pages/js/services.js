// Generated by LiveScript 1.2.0
var ref$, values, pairsToObj, objToPairs, askServices, ref;
ref$ = require('prelude-ls'), values = ref$.values, pairsToObj = ref$.pairsToObj, objToPairs = ref$.objToPairs;
askServices = angular.module('askServices', ['firebase']);
ref = new Firebase('https://askkkkk.firebaseio.com/');
askServices.factory('authService', ['$firebase', '$q'].concat(function($firebase, $q){
  var service;
  return service = {
    isCandidate: function(id, onComplete){
      var deferred;
      deferred = $q.defer();
      ref.child("users/" + id + "/candidate_id").once('value', function(snapshot){
        return deferred.resolve(snapshot.val());
      });
      return deferred.promise;
    },
    onLogin: function(arg$){
      var uid, id, provider, displayName, first_name, last_name, username, verified, email, link, birthday, userRef;
      uid = arg$.uid, id = arg$.id, provider = arg$.provider, displayName = arg$.displayName, first_name = arg$.first_name, last_name = arg$.last_name, username = arg$.username, verified = arg$.verified, email = arg$.email, link = arg$.link, birthday = arg$.birthday;
      userRef = ref.child("users/" + id);
      userRef.update({
        uid: uid,
        id: id,
        provider: provider,
        user_id: id,
        displayName: displayName,
        first_name: first_name,
        last_name: last_name,
        username: username,
        verified: verified,
        email: email,
        link: link,
        birthday: birthday
      });
      return userRef.child('online').once('value', function(snapshot){
        if (snapshot.val()) {
          return;
        }
        userRef.child('online').set(true);
        return userRef.child('last_login_time').set(new Date().getTime());
      });
    },
    onLogout: function(arg$){
      var id, userRef;
      id = arg$.id;
      userRef = ref.child("users/" + id);
      return userRef.child('online').set(false);
    }
  };
}));
askServices.factory('candidateService', ['$firebase'].concat(function($firebase){
  var x$, service;
  x$ = service = $firebase(ref.child('candidates'));
  x$.get = function(id){
    return service.$child(id);
  };
  return x$;
}));
askServices.factory('questionService', ['$firebase'].concat(function($firebase){
  var x$, service;
  x$ = service = $firebase(ref.child('questions'));
  x$.$on('child_added', function(arg$){
    var snapshot, prevChild;
    snapshot = arg$.snapshot, prevChild = arg$.prevChild;
    service[snapshot.name].addressing = service.$child(snapshot.name + "/addressing");
    return service[snapshot.name].asker = $firebase(ref.child("users/" + snapshot.value.asker));
  });
  x$.post = function(arg$, onComplete){
    var title, content, category, addressing, post_date, deadline, asker;
    title = arg$.title, content = arg$.content, category = arg$.category, addressing = arg$.addressing, post_date = arg$.post_date, deadline = arg$.deadline, asker = arg$.asker;
    return ref.child('candidates').once('value', function(snapshot){
      var candidates;
      candidates = snapshot.val();
      addressing = pairsToObj(addressing.map(function(it){
        return [
          it, {
            state: 'pending'
          }
        ];
      }));
      return service.$add({
        title: title,
        content: content,
        category: category,
        addressing: addressing,
        post_date: post_date,
        deadline: deadline,
        asker: asker,
        state: {
          collecting: 'collecting'
        },
        responses_count: 0,
        signatures_count: 0,
        votes_count: 0
      }).then(function(postRef){
        (function(meta){
          meta.$child("collecting/" + postRef.name()).$set(true);
        }.call(this, $firebase(ref.child('question_index'))));
        (function(meta){
          var i$, ref$, len$, c;
          for (i$ = 0, len$ = (ref$ = category).length; i$ < len$; ++i$) {
            c = ref$[i$];
            meta.$child(c + "/" + postRef.name()).$set(true);
          }
        }.call(this, $firebase(ref.child('category'))));
        (function(meta){
          var i$, ref$, len$, c;
          for (i$ = 0, len$ = (ref$ = keys(addressing)).length; i$ < len$; ++i$) {
            c = ref$[i$];
            meta.$child(c + "/questions/" + postRef.name()).$set(true);
          }
        }.call(this, $firebase(ref.child('candidate_meta'))));
        if (onComplete) {
          return onComplete(postRef);
        }
      });
    });
  };
  x$.get = function(questionId){
    var x$, questionRef;
    x$ = questionRef = service.$child(questionId);
    x$.$on('loaded', function(snap){
      questionRef.$id = questionId;
      questionRef.addressing = questionRef.$child("addressing");
      return questionRef.asker = $firebase(ref.child("users/" + questionRef.asker));
    });
    return x$;
  };
  return x$;
}));
askServices.factory('signService', ['$firebase'].concat(function($firebase){
  var service;
  return service = {
    signature_threshold: 500,
    sign: function(userId, questionId){
      return ref.child("questions/" + questionId + "/signatures/" + userId).once('value', function(snapshot){
        var today, x$, y$;
        if (snapshot.val()) {
          return;
        }
        today = new Date();
        x$ = ref.child("questions/" + questionId + "/signatures/" + userId);
        x$.setWithPriority({
          date: {
            year: today.getFullYear(),
            month: today.getMonth() + 1,
            day: today.getDate()
          }
        }, today.getTime());
        y$ = ref.child("questions/" + questionId + "/signatures_count");
        y$.transaction(function(currentValue){
          return currentValue + 1;
        });
        y$.on('value', function(snapshot){
          console.log(snapshot.val());
          if (snapshot.val() >= service.signature_threshold) {
            return ref.child("questions/" + questionId + "/state/passed").set('passed');
          }
        });
        return y$;
      });
    }
  };
}));
/**
 * Filter an object to an array of its keys (properties) except those given be AngularFire.
 */
askServices.filter('toKeys', function(){
  return function(input, attributes){
    switch (false) {
    case !!angular.isObject(input):
      return input;
    default:
      return keys(input).filter(function(it){
        return it[0] !== '$';
      });
    }
  };
});
/**
 * Filter questions by candidate responses.
 */
askServices.filter('respondedByCandidate', function(){
  return function(input, attributes){
    switch (false) {
    case !!attributes:
      return null;
    case !angular.isArray(input):
      return input.filter(function(it){
        return it.addressing[attributes];
      }).filter(function(it){
        return it.addressing[attributes].state === 'responded';
      });
    case !!input.addressing:
      return null;
    case !!input.addressing[attributes]:
      return null;
    default:
      return input.addressing[attributes].state === 'responded';
    }
  };
});
/**
 * Filter questions by candidate responses.
 */
askServices.filter('pendedByCandidate', function(){
  return function(input, attributes){
    switch (false) {
    case !!attributes:
      return null;
    case !angular.isArray(input):
      return input.filter(function(it){
        return it.addressing[attributes];
      }).filter(function(it){
        return it.addressing[attributes].state === 'pended';
      });
    case !!input.addressing:
      return null;
    case !!input.addressing[attributes]:
      return null;
    default:
      return input.addressing[attributes].state === 'pended';
    }
  };
});