// Generated by LiveScript 1.5.0
(function(){
  var ref$, values, pairsToObj, objToPairs, askServices, signature_threshold;
  ref$ = require('prelude-ls'), values = ref$.values, pairsToObj = ref$.pairsToObj, objToPairs = ref$.objToPairs;
  askServices = angular.module('askServices', ['firebase', 'conf']);
  signature_threshold = 500;
  askServices.factory('authService', ['$q', 'conf'].concat(function($q, conf){
    var config, ref, service;
    config = {
      apiKey: conf.apiKey,
      authDomain: conf.authDomain,
      databaseURL: conf.firebase
    };
    firebase.initializeApp(config);
    ref = firebase.database().ref();
    return service = {
      isCandidate: function(id){
        var deferred;
        deferred = $q.defer();
        ref.child("users/" + id + "/candidate_id").once('value', function(snapshot){
          return deferred.resolve(snapshot.val());
        });
        return deferred.promise;
      },
      get: function(id){
        var deferred;
        deferred = $q.defer();
        ref.child("users/" + id).once('value', function(snapshot){
          return deferred.resolve(snapshot.val());
        });
        return deferred.promise;
      },
      onLogin: function(arg$){
        var uid, id, provider, displayName, ref$, first_name, last_name, username, verified, email, link, birthday, userRef;
        uid = arg$.uid, id = arg$.id, provider = arg$.provider, displayName = (ref$ = arg$.displayName) != null ? ref$ : '', first_name = (ref$ = arg$.first_name) != null ? ref$ : '', last_name = (ref$ = arg$.last_name) != null ? ref$ : '', username = (ref$ = arg$.username) != null ? ref$ : '', verified = (ref$ = arg$.verified) != null ? ref$ : '', email = (ref$ = arg$.email) != null ? ref$ : '', link = (ref$ = arg$.link) != null ? ref$ : '', birthday = (ref$ = arg$.birthday) != null ? ref$ : '';
        userRef = ref.child("users/" + id);
        userRef.update({
          uid: uid,
          id: id,
          provider: provider,
          user_id: id,
          displayName: displayName,
          first_name: first_name,
          last_name: last_name,
          username: username,
          verified: verified,
          email: email,
          link: link,
          birthday: birthday
        });
        return userRef.child('online').once('value', function(snapshot){
          if (snapshot.val()) {
            return;
          }
          userRef.child('online').set(true);
          return userRef.child('last_login_time').set(new Date().getTime());
        });
      },
      onLogout: function(arg$){
        var id, userRef;
        id = arg$.id;
        userRef = ref.child("users/" + id);
        return userRef.child('online').set(false);
      }
    };
  }));
  askServices.factory('candidateService', ['$firebaseObject', 'conf'].concat(function($firebaseObject, conf){
    var ref, x$, service;
    ref = firebase.database().ref();
    x$ = service = $firebaseObject(ref.child('candidates'));
    x$.get = function(id){
      return service.$child(id);
    };
    return x$;
  }));
  askServices.factory('userService', ['$firebaseObject', 'conf'].concat(function($firebaseObject, conf){
    var ref, service;
    ref = firebase.database().ref();
    return service = {
      get: function(id){
        return $firebaseObject(ref.child("users/" + id));
      }
    };
  }));
  askServices.factory('questionService', ['$firebaseObject', '$q', 'conf'].concat(function($firebaseObject, $q, conf){
    var ref, x$, service;
    ref = firebase.database().ref();
    x$ = service = $firebaseObject(ref.child('questions'));
    x$.$on('child_added', function(arg$){
      var snapshot, prevChild;
      snapshot = arg$.snapshot, prevChild = arg$.prevChild;
      service[snapshot.name].$addressing = service.$child(snapshot.name + "/addressing");
      service[snapshot.name].$asker = $firebaseObject(ref.child("users/" + snapshot.value.asker));
      return service[snapshot.name].postResponse = function(arg$){
        var postDate, responser, content;
        postDate = arg$.postDate, responser = arg$.responser, content = arg$.content;
        ref.child("questions/" + snapshot.name + "/addressing/" + responser + "/state").set('responded');
        ref.child("questions/" + snapshot.name + "/responses_count").transaction(function(currentValue){
          return currentValue + 1;
        });
        return service.$child("questions/" + snapshot.name + "/responses").$add({
          responser: responser,
          postDate: {
            year: postDate.getFullYear(),
            month: postDate.getMonth() + 1,
            day: postDate.getDate()
          },
          upVotesCount: 0,
          downVotesCount: 0,
          content: content.split(/\n\n/)
        });
      };
    });
    x$.$on('child_changed', function(arg$){
      var snapshot, prevChild;
      snapshot = arg$.snapshot, prevChild = arg$.prevChild;
      service[snapshot.name].$addressing = service.$child(snapshot.name + "/addressing");
      return service[snapshot.name].$asker = $firebaseObject(ref.child("users/" + snapshot.value.asker));
    });
    x$.get = function(questionId){
      var x$, questionRef;
      x$ = questionRef = service.$child(questionId);
      x$.$on('loaded', function(snap){
        questionRef.$id = questionId;
        questionRef.$addressing = questionRef.$child("addressing");
        questionRef.$responses = questionRef.$child("responses");
        questionRef.$asker = $firebaseObject(ref.child("users/" + questionRef.asker));
        return questionRef.postResponse = function(arg$){
          var postDate, responser, content, deferred, rRef;
          postDate = arg$.postDate, responser = arg$.responser, content = arg$.content;
          ref.child("questions/" + questionId + "/addressing/" + responser + "/state").set('responded');
          ref.child("questions/" + questionId + "/responses_count").transaction(function(currentValue){
            return currentValue + 1;
          });
          deferred = $q.defer();
          rRef = ref.child("questions/" + questionId + "/responses").push();
          rRef.set({
            id: rRef.name(),
            responser: responser,
            postDate: {
              year: postDate.getFullYear(),
              month: postDate.getMonth() + 1,
              day: postDate.getDate()
            },
            upVotesCount: 0,
            downVotesCount: 0,
            content: content.split(/\n\n/)
          }, function(){
            return deferred.resolve();
          });
          return deferred.promise;
        };
      });
      return x$;
    };
    x$.post = function(arg$, onComplete){
      var title, content, category, addressing, post_date, deadline, asker;
      title = arg$.title, content = arg$.content, category = arg$.category, addressing = arg$.addressing, post_date = arg$.post_date, deadline = arg$.deadline, asker = arg$.asker;
      return ref.child('candidates').once('value', function(snapshot){
        var candidates;
        candidates = snapshot.val();
        addressing = pairsToObj(addressing.map(function(it){
          return [
            it, {
              state: 'pending'
            }
          ];
        }));
        content = content.split(/\n\n/);
        return service.$add({
          title: title,
          content: content,
          category: category,
          addressing: addressing,
          post_date: post_date,
          deadline: deadline,
          asker: asker,
          state: {
            collecting: 'collecting'
          },
          responses_count: 0,
          signatures_count: 0,
          votes_count: 0
        }).then(function(postRef){
          (function(meta){
            meta.$child("collecting/" + postRef.name()).$set(true);
          }.call(this, $firebaseObject(ref.child('question_index'))));
          (function(meta){
            var i$, ref$, len$, c;
            for (i$ = 0, len$ = (ref$ = category).length; i$ < len$; ++i$) {
              c = ref$[i$];
              meta.$child(c + "/" + postRef.name()).$set(true);
            }
          }.call(this, $firebaseObject(ref.child('category'))));
          (function(meta){
            var i$, ref$, len$, c;
            for (i$ = 0, len$ = (ref$ = keys(addressing)).length; i$ < len$; ++i$) {
              c = ref$[i$];
              meta.$child(c + "/questions/" + postRef.name()).$set(true);
            }
          }.call(this, $firebaseObject(ref.child('candidate_meta'))));
          if (onComplete) {
            return onComplete(postRef);
          }
        });
      });
    };
    x$.upVoteResponse = function(arg$){
      var questionId, responseId, userId, rRef;
      questionId = arg$.questionId, responseId = arg$.responseId, userId = arg$.userId;
      rRef = ref.child("questions/" + questionId + "/responses/" + responseId);
      return rRef.child("votes/" + userId).once('value', function(snapshot){
        if (snapshot.val()) {
          return;
        }
        rRef.child("upVotes/" + userId).set(new Date().getTime());
        rRef.child("upVotesCount").transaction(function(it){
          return it + 1;
        });
        rRef.child("votes/" + userId).set(new Date().getTime());
        return rRef.child("votesCount").transaction(function(it){
          return it + 1;
        });
      });
    };
    x$.downVoteResponse = function(arg$){
      var questionId, responseId, userId, rRef;
      questionId = arg$.questionId, responseId = arg$.responseId, userId = arg$.userId;
      rRef = ref.child("questions/" + questionId + "/responses/" + responseId);
      return rRef.child("votes/" + userId).once('value', function(snapshot){
        if (snapshot.val()) {
          return;
        }
        rRef.child("downVotes/" + userId).set(new Date().getTime());
        rRef.child("downVotesCount").transaction(function(it){
          return it + 1;
        });
        rRef.child("votes/" + userId).set(new Date().getTime());
        return rRef.child("votesCount").transaction(function(it){
          return it + 1;
        });
      });
    };
    return x$;
  }));
  askServices.factory('signService', ['$firebaseObject', 'conf'].concat(function($firebaseObject, conf){
    var ref, service;
    ref = firebase.database().ref();
    return service = {
      signature_threshold: signature_threshold,
      sign: function(userId, questionId){
        return ref.child("questions/" + questionId + "/signatures/" + userId).once('value', function(snapshot){
          var today, x$, y$;
          if (snapshot.val()) {
            return;
          }
          today = new Date();
          x$ = ref.child("questions/" + questionId + "/signatures/" + userId);
          x$.setWithPriority({
            date: {
              year: today.getFullYear(),
              month: today.getMonth() + 1,
              day: today.getDate()
            }
          }, today.getTime());
          y$ = ref.child("questions/" + questionId + "/signatures_count");
          y$.transaction(function(currentValue){
            return currentValue + 1;
          });
          y$.on('value', function(snapshot){
            console.log(snapshot.val());
            if (snapshot.val() >= signature_threshold) {
              return ref.child("questions/" + questionId + "/state/passed").set('passed');
            }
          });
          return y$;
        });
      }
    };
  }));
  /**
   * Filter an object to an array of its keys (properties) except those given be AngularFire.
   */
  askServices.filter('toKeys', function(){
    return function(input, attributes){
      switch (false) {
      case !!angular.isObject(input):
        return input;
      default:
        return keys(input).filter(function(it){
          return it[0] !== '$';
        });
      }
    };
  });
  /**
   * Filter questions by candidate responses.
   */
  askServices.filter('respondedByCandidate', function(){
    return function(input, candidateId){
      switch (false) {
      case !!candidateId:
        return null;
      case !angular.isArray(input):
        return input.filter(function(it){
          return it.addressing[candidateId];
        }).filter(function(it){
          return it.addressing[candidateId].state === 'responded';
        });
      case !!input.addressing:
        return null;
      case !!input.addressing[candidateId]:
        return null;
      default:
        return input.addressing[candidateId].state === 'responded';
      }
    };
  });
  /**
   * Filter questions by candidate responses.
   */
  askServices.filter('pendedByCandidate', function(){
    return function(input, candidateId){
      switch (false) {
      case !!candidateId:
        return null;
      case !angular.isArray(input):
        return input.filter(function(it){
          return it.addressing[candidateId];
        }).filter(function(it){
          return it.addressing[candidateId].state === 'pending';
        });
      case !!input.addressing:
        return null;
      case !!input.addressing[candidateId]:
        return null;
      default:
        return input.addressing[candidateId].state === 'pending';
      }
    };
  });
  /**
   * Filter questions by signature threshold.
   */
  askServices.filter('passedThreshold', function(){
    return function(input){
      switch (false) {
      case !!input:
        return null;
      case !angular.isArray(input):
        return input.filter(function(it){
          return it.state.passed;
        });
      case !input.state.passed:
        return input;
      default:
        return null;
      }
    };
  });
}).call(this);
