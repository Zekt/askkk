// Generated by LiveScript 1.2.0
var keys, Firebase, AskKK;
keys = require('prelude-ls').keys;
Firebase = require('firebase');
AskKK = (function(){
  AskKK.displayName = 'AskKK';
  var prototype = AskKK.prototype, constructor = AskKK;
  function AskKK(arg$){
    var firebaseUrl, ref$, firebase;
    firebaseUrl = (ref$ = arg$.firebaseUrl) != null ? ref$ : null, firebase = (ref$ = arg$.firebase) != null ? ref$ : null;
    if (firebase) {
      this._firebase = firebase;
    } else if (firebaseUrl) {
      this._firebase = new Firebase(baseUrl);
    } else {
      throw new Error("No Firebase provided.");
    }
    this._userId = 1;
    this._candidateId = 1;
  }
  /**
   * Set candidate info.  If there is a candidate of the
   * same ID, her/his info will be erased.
   */
  prototype.setCandidate = function(id, arg$, onComplete){
    var name, email, candidateRef;
    name = arg$.name, email = arg$.email;
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.set({
      id: id,
      name: name,
      email: email
    }, onComplete);
  };
  /**
   * Get candidate info from id.
   * Candidates ID are maintained by administrators.
   */
  prototype.getCandidate = function(id, onComplete){
    var candidateRef;
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Update candidate info.  If there is a candidate of the
   * same ID, only the info specified in data will be updated.
   */
  prototype.updateCandidate = function(id, data, onComplete){
    var d, i$, ref$, len$, k, candidateRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.update(d, onComplete);
  };
  /**
   * Create a user.  User IDs are created by the `push`
   * method of Firebase.  onComplete is a callback whose
   * argument is an object containing user info, including ID.
   */
  prototype.createUser = function(arg$, onComplete){
    var name, email, usersRef, newRef;
    name = arg$.name, email = arg$.email;
    usersRef = this._firebase.child('/users');
    newRef = usersRef.push();
    return newRef.set({
      id: newRef.name(),
      name: name,
      email: email
    }, function(error){
      if (error) {
        return onComplete(error);
      } else {
        return newRef.on('value', function(snapshot){
          return onComplete(snapshot.val());
        });
      }
    });
  };
  /**
   * Get user info by ID.
   */
  prototype.getUser = function(id, onComplete){
    var userRef;
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Update user info.
   * Only the info specified in the data will be updated.
   * If there are no user of the given ID, nothing happens,
   * and onComplete will be called with a null.
   */
  prototype.updateUser = function(id, data, onComplete){
    var d, i$, ref$, len$, k, userRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      if (snapshot.val()) {
        return userRef.update(d, function(snapshot){
          return userRef.on('value', function(snapshot){
            return onComplete(snapshot.val());
          });
        });
      } else {
        return onComplete();
      }
    });
  };
  /**
   * Create a petition.
   */
  prototype.createPetition = function(arg$, onComplete){
    var title, candidates, story, petitionRef, userPetitionRef, candidateMetaRef, petitionIndexRef, data;
    title = arg$.title, candidates = arg$.candidates, story = arg$.story;
    if (!this._userId) {
      throw new Error("Need to be a user to create a petition.");
    }
    petitionRef = this._firebase.child('petitions').push();
    userPetitionRef = this._firebase.child('user_meta').child(this._userId).child('petitions');
    candidateMetaRef = this._firebase.child('candidate_meta');
    petitionIndexRef = this._firebase.child('petition_index');
    data = {
      id: petitionRef.name(),
      author: this._userId,
      title: title,
      candidates: candidates,
      story: story
    };
    return petitionRef.set(data, function(error){
      var i$, ref$, len$, ca;
      if (error) {
        throw new Error("Error created a petition: " + error);
      }
      userPetitionRef.child(petitionRef.name()).set(true);
      for (i$ = 0, len$ = (ref$ = keys(candidates)).length; i$ < len$; ++i$) {
        ca = ref$[i$];
        candidateMetaRef.child(ca).child('petitions').child(petitionRef.name()).set(true);
      }
      petitionIndexRef.child('open').child(petitionRef.name()).set(true);
      return onComplete(data);
    });
  };
  /**
   * Get petition info
   */
  prototype.getPetition = function(id, onComplete){
    return this._firebase.child('petitions').child(id).on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Sign an open petition to agree that it should be answered.
   * Example: sign('-JFsstiW6QzJkRG3kh09', function (error) {})
   */
  prototype.sign = function(id, onComplete){
    var petitionMetaRef, signatureRef;
    if (!this._userId) {
      throw new Error("Need to be a user to sign a petition.");
    }
    petitionMetaRef = this._firebase.child('petition_meta').child(id);
    signatureRef = petitionMetaRef.child('signatures').child(this._userId);
    return signatureRef.on('value', function(snapshot){
      if (snapshot.val()) {
        return onComplete(null);
      }
      return signatureRef.set(true, function(error){
        if (error) {
          onComplete(error);
        }
        return petitionMetaRef.child('signatures/total').transaction(function(currentValue){
          return currentValue + 1;
        }, function(error, committed, snapshot){
          return onComplete(snapshot.val());
        });
      });
    });
  };
  /**
   * Respond to a petition.
   */
  prototype.respond = function(){};
  /**
   * Vote an answer as good/not good.
   */
  prototype.vote = function(){};
  return AskKK;
}());
module.exports.AskKK = AskKK;